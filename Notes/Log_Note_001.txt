- The Renderer class is kinda the central point for the Application class to inerface with graphics programming.
In Hazel, specifically in Renderer2D's class, the specifications can be found in the struct Renderer2DData defined in the same class cpp file.
Spike Engine's Pipeline Specification system, which can be found in the Pipeline class, can be considered as a cross-platform derivative of Hazel's
specification system.

Bottom line, a specification needs to be established, which will guide the Renderer in defining the Framebuffer, VertexBuffer and IndexBuffer.

So the Renderer Init functionality will have two stages
- Window Creation - Creating a GLFW window, and creating the proper Graphics context.
- Creating/initializing a viewport.

Afterwards, the Renderer will have to Create a RenderPipeline, which will take assorted types of specification data (look at the top of this note).
Using this, it will create the Framebuffers, swapchains, set the vertexbuffer layout with strides and all.

Then it will take the shaders from file, compile them into binaries and store them for usage.

Then it will take the Vertex data, the Index data, and then a draw call will draw the triangles on display.

Above mentioned 3 points can be segregated into abstraction APIs of itself - VertexLayout, VertexBuffer, IndexBuffer, Shader (Need to create 
endpoints for a Material system).

First task is to organize the intialization into a more architectural friendly understandable structure, cause right now, the flow is scattered here
and there, with multiple times where I have to search the symbols in order to understand where does the control come from and go to.